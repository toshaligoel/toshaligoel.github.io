<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.4.0/animate.min.css"> 
      
      <link rel="stylesheet" href="style.css">
      <link rel="icon" href="images/favicon.ico">
    <title>Bully Algorithm</title>
</head>
    
    <nav class="head-nav navbar navbar-expand-sm">
  
        <a class="navbar-brand" id="logo" href="index.html"><img src="images/logo_circle.png" alt="..." width="6.5%"></a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarNav">
    <ul class="navbar-nav ml-auto">
      <li class="nav-item">
        <a class="nav-link" href="index.html">HOME</a>
      </li>
      <li class="nav-item active">
        <a class="nav-link" href="projects.html">PROJECTS<span class="sr-only">(current)</span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="research.html">RESEARCH</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="ResumeTGMSCS.pdf">RESUME</a>
      </li>
    </ul>
  </div>
    </nav>
    
    
<body>

<div class="container">
    <br>
<h1>The Bully Algorithm</h1>

<h2>From Theoretical Understanding to Implementation</h2><br>
    <p class="center"><em>I worked on <a href="https://github.com/tgoel2/bully.git">implementing the Bully algorithm</a> for leader election in a distributed system. I worked with a partner on this project as part of 
        a course on Distributed Computing, and our implementation most heavily relied on <a href="http://homepage.divms.uiowa.edu/~ghosh/Bully.pdf">Hector Garcia-Molina's original conception of the algorithm.</a>
    </em></p><br><br>
    
        <img src="images/bully-readme.png" width="100%">
        <br><br>

        <div class="fadeInUp">
        <h3>Background and Motivation</h3>
        <p></p>
          <br>
            <div class="pill wow fadeInUp box container">
                <h5>The Bully Algorithm</h5>
                <div class="row">
                    <div class="col-lg-3">
<p><br>Leader election is a widely worked on problem in distributed computing that involves optimizing the method by which a particular process (or other entity) is assigned
    specific powers such as task management and delegation in order to best maximize the efficiency of the system as a whole. Introducing leaders can be greatly beneficial 
    to the overall distributed system but can also potentially reduce fault tolerance and other vulnerabilities, and finding an optimal solution to this problem
    remains a question.
</p>         
</div>
<div class="col-lg-9"><img src="images/bully-coordfuncs.png" width="100%"></div>
</div>
<br>
<p>The Bully algorithm is one such proposed method of electing a leader amongst several processes. The algorithm assumes that all 
    processes are aware of each other's IDs, and so any process can detect another's failure. When a process detects failure, it will send
    messages to all processes with higher IDs than its own. This should continue until the highest process is a candidate for election, 
    at which time it should send out an election message to all processes. Every process compares its own ID to the candidate, rejecting and 
    sending out its own election message if its own ID is larger. Eventually, the process with the highest ID should be elected leader.
</p>  
                <h5>Project Motivation</h5>
<p>We chose to work on this project for several reasons. As mentioned, leader election is a prominent problem in distributed systems. 
    But besides that, it is also one of the most theoretically understandable problems â€” and the Bully algorithm is similarly simple to 
    understand on a conceptual level.
</p>            
<p>The algorithm is also highly efficient, and optimal for fault tolerance in a distributed system as any process can be alerted to a failure. 
    It is synchronous, which makes it slightly more challenging to implement in real systems, but we wanted to try our hand at it given its theoretical merit.
</p>
<p>We decided to use RPCs to implement the bulk of the messaging in this algorithm, for heartbeat messages as well as candidate and election messages 
    which also helps in our quest to increase efficiency due to the practical use of RPCs in a distributed environment.
</p>
            </div><p></p>
            <h3>Synchronization and Timeout</h3><p></p>

            
            <div class="pill wow fadeInUp box">
                                    <div>
                                        <img class="album img-fluid rounded" src="images/bully-funcode.png">  
                                    </div>
         <br>
<p>For the Bully Algorithm to work properly, all processes in the distributed system must run synchronously to ensure that timeouts occur at the proper time in relation to the other processes. For this to happen, all processes need to be running on synchronized time. We decided to use the Time package in Golang
    to implement synchronized clocks, which allows our code to work on a truly distributed system (across multiple devices) as well as in local testing. We determined when a process had timed out by using the shared global current time added to the timeout value, which we predefined as a constant value.
</p>          </div><br>
            
        </div><p></p>
        <p>We were able to successfully implement the Bully algorithm using RPCs in the end, and tested our implementation using 
            a simulated distributed system we created with AWS EC2. We published our finished implementation in a <a href="https://github.com/tgoel2/bully.git">GitHub repo</a>.
        </p>
            
        </div>
        </div>
    <br><br>

    <footer class="foot-nav">
        <nav class="navbar navbar-expand-sm">
        <ul class="navbar-nav">
            <li class="nav-item">
                <a class="nav-link" href="mailto:toshaligoel@gmail.com">Email</a>
            <li class="nav-item"><a class="nav-link" href="https://www.linkedin.com/in/toshaligoel/">LinkedIn</a>
            </ul>
            
            <li class="nav-item nav-link ml-auto">
                &#9825; Designed and Coded by Toshali Goel &#9825; </li>
            
        </nav>
    </footer>

<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wow/1.1.2/wow.min.js">
</script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>


    <script src="script.js"></script>
    <script> new WOW().init(); </script>

    </body>
    </html>
